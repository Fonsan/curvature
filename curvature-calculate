#!/usr/bin/env python
# -*- coding: UTF-8 -*-

# curvature-calculate
#
# Find roads that are the most curved or twisty based on Open Street Map (OSM) data.
#
# The goal of this script is to help those who enjoy twisty roads (such as
# motorcycle or driving enthusiasts) to find promising roads that are not well known.
# It works by calculating a synthetic "curvature" parameter for each road segment
# (known as a "way" in OSM parlance) that represents how twisty that segment is.
# These twisty segments can then be output as KML files that can be viewed in Google Earth
# or viewed in tabular form.
#
# About the "curvature" parameter:
# The "curvature" of a way is determined by iterating over every set of three points
# in the line. Each set of three points form a triangle and that triangle has a circumcircle
# whose radius corresponds to the radius of the curve for that set. Since every line
# segment (between two points) is part of two separate triangles, the radius of the curve
# at that segment is considdered to be the average of the radii for its member sets.
# Now that we have a curve radius for each segment we can categorize each segment into
# ranges of radii from very tight (short radius turn) to very broad or straight (long radius turn).
# Once each segment is categorized its length can be multiplied by a weighting (by default
# zero for straight segments, 1 for broad curves, and up to 2 for the tightest curves).
# The sum of all of these weighting gives us a number for curvature that corresponds
# proportionally to the distance (in meters) that you will be in a turn.*
#
# * If all weights are 1 then the curvature parameter will be exactly the distance
#   in turns. The goal of this project however is to prefer tighter turns, so sharp
#   corners are given an increased weight.
#
# Author: Adam Franco
# https://github.com/adamfranco/curvature
# Copyright 2012 Adam Franco
# License: GNU General Public License Version 3 or later

import os
import copy
import re
import ast
import sys
import argparse
from curvature.collector import WayCollector
import codecs
import msgpack

# Set our output to default to UTF-8
reload(sys)
sys.setdefaultencoding('utf-8')
# sys.stdout = codecs.getwriter('utf8')(sys.stdout)
sys.stderr = codecs.getwriter('utf8')(sys.stderr)

parser = argparse.ArgumentParser(description='Find the roads that are most twisty in an Open Street Map (OSM) XML file.')
parser.add_argument('-v', action='store_true', help='Verbose mode, showing status output')
parser.add_argument('--min_length', type=float, default=1, help='the minimum length of a way that should be included, in miles, 0 for no minimum. The default is 2.0')
parser.add_argument('--max_length', type=float, default=0, help='the maximum length of a way that should be included, in miles, 0 for no maximum. The default is 0')
parser.add_argument('--level_1_max_radius', type=int, default=175, help='the maximum radius of a curve (in meters) that will be considered part of level 1. Curves with radii larger than this will be considered straight. The default is 175')
parser.add_argument('--level_1_weight', type=float, default=1, help='the weight to give segments that are classified as level 1. Default 1')
parser.add_argument('--level_2_max_radius', type=int, default=100, help='the maximum radius of a curve (in meters) that will be considered part of level 2. The default is 100')
parser.add_argument('--level_2_weight', type=float, default=1.3, help='the weight to give segments that are classified as level 2. Default 1.3')
parser.add_argument('--level_3_max_radius', type=int, default=60, help='the maximum radius of a curve (in meters) that will be considered part of level 3. The default is 60')
parser.add_argument('--level_3_weight', type=float, default=1.6, help='the weight to give segments that are classified as level 3. Default 1.6')
parser.add_argument('--level_4_max_radius', type=int, default=30, help='the maximum radius of a curve (in meters) that will be considered part of level 4. The default is 30')
parser.add_argument('--level_4_weight', type=float, default=2, help='the weight to give segments that are classified as level 4. Default 2')
parser.add_argument('--ignored_surfaces', type=str, default='dirt,unpaved,gravel,fine_gravel,sand,grass,ground', help='a list of the surfaces that should be ignored. The default is dirt,unpaved,gravel,fine_gravel,sand,grass,ground')
parser.add_argument('--highway_types', type=str, default='secondary,residential,tertiary,primary,primary_link,motorway,motorway_link,road,trunk,trunk_link,unclassified', help='a list of the highway types that should be included. The default is secondary,residential,tertiary,primary,primary_link,motorway,motorway_link,road,trunk,trunk_link,unclassified')
parser.add_argument('--straight_segment_split_threshold', type=float, default=1.5, help='If a way has a series of non-curved segments longer than this (miles), the way will be split on that straight section. Use 0 to never split ways. The default is 1.5')
parser.add_argument('file', type=argparse.FileType('r'), nargs='+', help='the input file. Should be an OSM XML file or PBF file.')
args = parser.parse_args()

# Instantiate our collector
collector = WayCollector()

# Configure settings based on the command-line arguments
collector.verbose = args.v
collector.ignored_surfaces = args.ignored_surfaces.split(',')
collector.roads = args.highway_types.split(',')
collector.level_1_max_radius = args.level_1_max_radius
collector.level_1_weight = args.level_1_weight
collector.level_2_max_radius = args.level_2_max_radius
collector.level_2_weight = args.level_2_weight
collector.level_3_max_radius = args.level_3_max_radius
collector.level_3_weight = args.level_3_weight
collector.level_4_max_radius = args.level_4_max_radius
collector.level_4_weight = args.level_4_weight
collector.straight_segment_split_threshold = args.straight_segment_split_threshold * 1609

# start parsing
for file in args.file:
	if args.v:
		sys.stderr.write("\nLoading {}".format(file.name))

	collector.load_file(file.name)
	for way in collector.ways:
		# Remove the refs from our constituents as they are node ids for objects we no longer have
		if 'constituents' in way:
			for c,v in enumerate(way['constituents']):
				if 'refs' in way['constituents'][c]:
					del way['constituents'][c]['refs']
		
		sys.stdout.write(msgpack.packb(way))

if args.v:
	sys.stderr.write("\ndone.\n")
